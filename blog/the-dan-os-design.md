---
title: Dan OS 设计
author: flytreleft
author_title: Creator of Crazydan Studio
author_url: https://flytreeleft.org
author_image_url: /img/avatar/flytreeleft.svg
tags:
- Dan OS
- 软件基础设施
- 新操作系统
- 数据结构化
- 应用函数化
description:
image:
---

> - Dan OS 的设计仍在逐步改进与完善中，本文将随时发生变化，感兴趣的朋友们可以时刻保持关注；
> - 在文末有本文编者的联系方式，有不同意见和建议的朋友可以与其保持联系；

`Dan OS`（也称为**蛋 OS**）是一款面向**结构化数据**和**函数化应用**的操作系统。

`Dan OS` 试图以**破局者**的身份，对当前的软件开发基础发起挑战，并提出其所认为的行之有效的、富有改革性的改进方案，
以实现从底层彻底（但不一定绝对）优化**软件基础设施**，让软件开发能够摆脱**思想枷锁**、卸下**历史包袱**，
从而向未来加速前进。

这不是一场「你生我灭」的斗争和较量，而是「后浪推前浪」的数字**进化与变革**。

`Dan OS` 必然是在基于前辈们大量的工作之上而诞生的，也必然是饱含「敬畏之心」的，
她也不会野心勃勃地去推翻一切以重建一个「乌邦托」的世界，她只是在以自己的行动向世人表明其对数字世界的变革之心，
并期望能够有更多人参与到这场变革之中，贡献出自己的想法与力量，让未来的数字世界变得更加美好。

<!-- more -->

<img src="/img/danos/danos-boot.jpg" alt="Dan OS 启动界面"/>

## 应对挑战

### 数据格式的千奇百怪

当下的数据真的是格式种类和编解码方式繁多，且均“自成一派”，在集几代人智慧的结晶后，逐渐拥有完整且庞大的生态体系。

百花齐放本不是什么不好的事情，但从数字化的底层就开始各行其事，便在无形之中加重了数字化体系的整体负担，
让软件开发工作变得越发繁重，也让软件使用变得复杂，计算资源变得紧缺。

> 在应用交互和功能层面的“争奇斗艳”才是编者所真正期盼的。

各种数据格式在自己的生态内也许还能风生水起，但当要与其他生态进行数据交互时，便会变得困难起来。
因为，在不同的生态中会采用不同的编程语言，对相同数据会使用不同的编解码机制，
在消费端就需要编写相应的代码将生产端的数据进行解析，再向生产端返回其可以理解的格式化数据。

而在同一生态内，其存储的数据也和其在运行中所处理的数据不同，同样免不了地要进行数据的编解码工作。

也就是，无论是围绕数据格式的生态内外，均存在大量的代码、大量的计算资源，需要用于对数据的编解码上。
这也就使得在程序开发上，需要大量的人力和脑力资源消耗在数据格式转换和解析上。

并且，软件自身的维护成本也会上升，特别是在跨多个硬件平台、多个软件生态时，其所要维护的工作量也必然陡增。
工作量和维护成本的增加，也就会产生大量的显性和隐性的缺陷和漏洞，并反过来进一步提升开发成本。

其实，从本质上而言，各种数据格式也无太大差异，至少在应用程序处理时，
都免不了要将对应格式的数据转换为可识别的、业务逻辑清晰、数据指代明确的「结构化」数据。

但是，在多个位置、多个技术方案中对同一数据做转换，会因为理解不同、处理方式不同等因素，
造成数据解析出现偏差，并且，在涉及面很广的环境下，对数据格式做出变化也是极为困难的，
极易造成系统的不稳定，需要对代码进行大量调整和测试。

因此，只要在应用内外都采用**结构化数据**便能够避免以上问题，应用在拿到数据的那一刻都已经是结构化了的数据，
应用只需要依据确定的数据结构进行处理即可，无需再做任何转换，也不需要担心数据存在结构和语义不明的地方。

要做到这一点，仅靠对应用进行规范是无法彻底实现的。必须要从应用运行的底层（即，操作系统）作出改变才行。

此外，具备相同功能的应用在不同硬件平台上，也存在不同的（文件）格式，为了让程序在不同硬件上跑起来，
就必须将代码编译成不同的二进制代码。这同样是数据交换过程中的编解码行为，
只是该行为发生在操作系统层面而非应用层面。

但是，细究起来，**应用本身也是数据**，只不过其自身主要包含的是数据「处理函数」，
而这些处理函数会被编译成机器指令，操作系统再将这些指令喂给CPU去执行。

当然，函数没法实现结构化，并且，目前也无法将函数直接交给CPU执行，
但我们确实很有必要为应用中的处理函数提供统一且一致的跨平台的运行环境，
正如`JVM`（对应`Java`语言）、`BEAM`（对应`Erlang`语言）等代码执行的虚拟机一样，
让代码能够直接被解释执行，而无需再编译。

这样，应用的实体（二进制文件）也就不复存在，所留下的只有**数据 + 数据处理函数**，
整个操作系统也会成为一个大的函数体，负责执行其他函数（但不会缺失多线程等并发特性）。
各个应用之间也能够很方便地**共享函数**，而不是在二进制形式时，以动态链接库的形式共享数据处理能力，
数据也可以在不做迁移的情况下实现各类数据处理，只需要将数据处理函数分享到数据所在的系统上执行便可。

所以，`Dan OS` 需要做的便是：
- 将一切**数据结构化**，包括文件，避免在应用内外对数据进行编码和解码处理
  - 结构是自描述的、版本化的、向前兼容的
  - 数据结构的变化不影响未升级应用的稳定性（可适当无可展示的数据）
- 将**应用函数化**，不再以二进制方式分发应用，而是以函数形式分发和执行
  - 函数不与数据绑定，且必须是「幂等」的
- 使用**底层一致**的编程语言编写函数，从而消除代码不兼容和各自为政的状态
  - 在相同的底层语言之上可衍生各种领域模型语言或更高级的语言

### 应用生态的割裂与封闭

「以应用为中心」的数字化体系，正在堕入割裂与封闭的深渊，最终走向无尽的黑暗。

不同的应用有各自不同的开发机制、不同的操作逻辑、不同的处事哲学，使得用户体验各异，
应用之间割裂感严重，无法形成融合于操作系统的一致的数字化使用体验。

> 很多人推崇苹果电脑，也许正在于其统一且良好的用户体验所带来的流畅和舒适感。

围绕应用所形成的生态也具有排他性，因为其掌握对用户数据的「解释权」（即，如何解析数据），
所有改进尝试和功能扩展，均需要获得其许可，并遵守其随时可能发生变化的「游戏规则」。

在这样一个封闭的应用生态里，数据分享的壁垒将会越筑越高，商业的护城河也将越来越深。
数据的所有者反而逐步成为其「圈养的猪」，任何试图打破其壁垒的人都会被撞得头破血流。

应用生态间的数据，其存储格式、处理逻辑、展现风格等，都是不同的，数据无法在不同应用间共享。
数据所有者在通过某一生态内的应用创造了大量数据后，其便无法再切换到其他生态的应用上，
因为，切换应用，意味着前面产生的数据都将无法使用，一切就都得从头开始，
这样的切换成本是极为高昂的。

应用切换成本的高昂，反而使得应用成为「吸血的蚊子」，持续不断地为魔鬼输送养分。

割裂与封闭，势必造成生态内的优秀成果不能共享，用户的各类数据无法积累起来，
新的应用只能从零开始构建，从空白开始运行，用户也只能不断「在白纸上作画」。

所以，`Dan OS` 需要做的便是：
- **以数据为中心**构建应用生态，应用只是为数据服务，而不是数据的“管家”，
  用户可随时替换不满意的应用
  - **数据是用户的数据，而不是应用的数据**
- 应用可互相集成、互相调用，且交互体验上必须是一致和流畅的，应用不能“喧宾夺主”，
  要扮好数据服务者的角色
- 任何数据均具备唯一链接，其在应用间可相互跳转，在应用内也可以随时直达目标数据
- 提供统一的用户交互界面，负责控制数据联动、数据展示、用户事件响应等，
  具体的界面样式、动效等可由用户根据个人喜好自行定制，且定制作用于整个系统

### 用户数据的所有权与控制权

<!--
去中心化只是附属产物，其也不是与中心化完全对立。
只是为了让数据的所有者能够对自己的数据拥有更多的控制权和处置权，
让中心化服务商对用户数据更有敬畏之心，厂商之间能够更加良性竞争。
-->

「去中心化」不是目的，而是将数据所有权、控制权和处置权归还数据所有者的结果。

为了实现该结果，应用可以是去中心化的，也可以是中心化的，或者二者相结合，
数据存储可以是分布式，也可以集中式。

数据所有者对数据的权利，就像是你对自己所拥有的实物的权利，
只能由你自己决定所属物该如何使用和处理，其他人均无权干预，甚至都不知道其存在。

所以，`Dan OS` 需要做的便是：
- 对用户数据**加密存储**，非数据所有者不能解密数据
- 数据的存储位置和使用方式只能由数据所有者确定，应用只能使用指定的数据，
  且数据在哪里，应用就在哪里运行

### 软件开发中的重复踩坑

前人遇过的坑，后人又不得不继续踩坑，软件开发史就是一部「血泪踩坑史」。

排雷成果难以共享和直接使用，阻碍共同进步。

各个项目均需要开发大量逻辑类似（但有些许差异）的组件，尽管各种开发语言都有很多框架，
但都会引入不同程度的入门难度、开发复杂度，以及各种缺陷。

所以，`Dan OS` 需要做的便是：
- 让应用开发仅专注于所要处理的数据结构、数据处理逻辑、数据展示以及用户交互逻辑，
  各种处理均为一个个函数，且函数是无状态的、幂等的
  - 面向对象类的高级语言中的函数会和对象状态绑定，故而可能会不太适用
- 相同逻辑的函数可被共享，相同的处理场景无需再编码，直接复用前人的成果：支持不分享源码
- 提供统一且一致的开发工具和文档工具，以支持根据数据结构自动匹配相关的处理函数，匹配来自于开发库
- 代码的可维护性是针对开发者而言的，写得工整漂亮的代码，对设备是没有意义的，
  而开发者真正的诉求是实现功能需求，并且能够方便地、快速地响应功能的变化需求。
  所以，开发者的本质需求不是针对代码的可维护性，而是针对功能的可适应性，
  最终的代码是怎样的，对开发者并不重要，开发者的聚焦点应该始终放在
  数据结构、数据处理逻辑、用户交互方式、数据来源和去向等方面，
  唯一涉及代码的地方，实际上只有 处理逻辑 这一块，
  但其应该是需关注如何计算出数据的新的状态，而不用管如何存储、如何获取、如何传输数据的状态

### 生产环境与测试环境的差异

测试环境难以复现生产环境中出现的问题，克隆完全的生产环境需要消耗大量的时间和人力成本，
在生产上做测试需要小心翼翼，往往测试不足。

所以，`Dan OS` 需要做的便是：
- 采取**数据版本化**、**数据不可变**机制，在任意时刻均可从从生产库中创建数据分支，
  生产继续在主线分支工作，测试则在衍生的分支上运行，当测试完毕后，直接删除分支即可，
  生产和测试同时进行也不会对两个环境的数据造成任何影响，同时，不再需要部署两套数据库，
  任何时候均使用同一个库即可
  - 依然需要控制好开发人员、测试人员对生产库的分支的访问和操作权限，
    避免涉敏数据被无关人员查看，以及涉密信息的泄漏
- 对于涉敏数据，可通过数据权限进行控制，对数据的权限控制精细到对属性的读写

### 软件开发中的依赖问题

- 依赖版本变更问题
- 依赖复杂度问题
- 依赖引入缺陷及缺陷修复问题
- 依赖代码重复：不同依赖中含有相同代码，相同依赖的不同版本也含有相同代码
- 被多方依赖的包做了漏洞修复，该如何快速在依赖方应用修复？
  - 自动在本地升级应用的实际依赖？

所以，`Dan OS` 需要做的便是：
- 函数版本化控制，且各个版本均不可删除，将一直存在。函数间的调用都是对某个确定版本的调用，
  外部函数升级不影响已经确定的调用
  - 应用升级，大概率不会升级全部函数，部分函数会保持不变，因此，
    以函数为存储单位可降低存储开销，并避免在不同应用间重复定义
- 调用时，引用的是函数名的唯一标识，因此，函数名称的变更不影响调用方函数
  - 函数名称只是便于开发人员阅读
  - 函数参数采用结构化数据，当参数仅是属性的增加时，同样不影响调用方函数，
    但需要注意业务处理上的变化
- 所有函数都有一个唯一的**名字空间**（Namespace），函数将打包在该名字空间下，
  并进行签名，非同一组织开发的函数必须放在全局唯一的名字空间下，不能与其他名字空间重复

### 变更回溯与灾备

- 应用断点恢复，零重启、零准备

所以，`Dan OS` 需要做的便是：
- 数据与函数以统一方式存储，并采用分布式存储
- 数据以及函数的状态实时更新，并同步至各个节点，以确保应用可在任意节点即刻就地恢复
  - 应该仅需要实时保存数据（含中间数据的）状态即可，系统重启等不会造成状态的丢失，
    应用可在系统启动后恢复到重启时的状态继续运行

### 应用与数据安全

- 应用隔离
- 权限最小化，权限控制到函数及数据属性，应用对系统函数和用户数据的访问需获得授权
- 数据加密
- 数据访问跟踪

### 应用臃肿与计算资源不够用

- 应用安装体积越来越到，大量功能不会用到或极少用到
- 计算机内存和CPU逐年提升，在运行应用时依然响应迟钝
- 重复数据、重复代码

所以，`Dan OS` 需要做的便是：
- 函数及数据的去重存储，相同数据在数据库中仅有一份（分布式中各个节点各有一份）

### 万物互联

- 所有外设都是计算的延伸，主要是用于接收输入、反馈输出
- 待处理数据量大
- 数据安全、使用者身份认证和权限控制

所以，`Dan OS` 需要做的便是：
- 通过数据转换和采集函数，将外设的零散数据整理为对象，再交给应用处理，并将应用的输出交给外设

## 功能特性

- 一切皆为结构化数据
  - 数据自带结构，消除编解码
  - 数据结构自描述：可自动化识别数据，并可自动与相关函数和数据等建立起联系
- 统一且一致的分布式层
  - 开放，连接，协作，共享
- 统一且一致的数据存取层
  - 高存取性能，规模无关
  - 结构化数据，数据之间任意层级的关联和实时查询
  - 数据不可变和版本化
- 统一且一致的程序语言
  - 消除程序碎片化与应用隔离，强制共建互利生态
- 统一且一致的开发界面
  - 数据定义及引用界面
  - 函数编写界面：附带函数说明、参数说明、使用样例等
  - 应用配置界面
  - 数据查询界面
  - 用户 UI 装配界面
  - 统一且规范的代码格式化：不支持自定义代码风格
- 应用程序函数化，函数可共享，可迁移
  - 减少重造的轮子，成果共享（仅结果非资产共享），实现生态内互利
- 函数及数据版本化
  - 依赖升级无破坏性，变更可跟踪可回溯
- 应用间运行环境完全隔离，以消息交换数据，权限最小化
- 中断的应用可从中断位置继续运行
  - 灾难恢复
- 原生且默认的数据加密
- 在自身这端提供对旧世界的接入层，该接入层以原有方式与其对接，再对收到的数据结构化后，
  返回给调用端（反之为该过程的逆过程），系统提供通用的对接支持和相应的工具

## 架构设计

OS 系统架构：

<img src="/img/danos/arch-v1.0.jpg" alt="Dan OS 架构 v1.0" height="600px"/>

- 驱动层与硬件交互硬件所支持的数据格式（非结构化数据），
  而驱动层与操作系统之间交互结构化数据（根据硬件特性所提取出的数据结构）
  - 如，UI 视图将组件的位置、样式、颜色、文本等结构化信息交给显示驱动，
    显示驱动再根据视图信息（包括对多个 UI 的整合）向显示器写入图形绘制数据，
    从而实现 UI 的显示
  - 每类设备的驱动，均为一个独立进程的服务函数，系统的应用通过对驱动数据的更新实现对设备的操作

UI 组件架构：

<img src="/img/danos/ui-arch-v1.0.jpg" alt="Dan OS UI 组件架构 v1.0" height="600px"/>

## 相关阅读

- [一种新的操作系统设计](http://www.yinwang.org/blog-cn/2013/04/14/os-design):
  转载文章在[这里](./a-new-os-design-by-wangyin)。
- [Pick Operating System](https://en.wikipedia.org/wiki/Pick_operating_system):
  A demand-paged, multiuser, virtual memory, time-sharing computer operating system
  based around a MultiValue database.
- 数据结构
  - [Tagged union](https://en.wikipedia.org/wiki/Tagged_union):
    `type Tree = Empty | Leaf Int | Node Tree Tree`
    - [Algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type)
  - [Record (computer science)](https://en.wikipedia.org/wiki/Record_(computer_science)):
    `type alias User = {name: String, age: Int}`
  - [Metadata](https://en.wikipedia.org/wiki/Metadata)
    - 粒度粗细会影响维护成本，故版本控制、属性引用id化能降低数据结构变更的影响
  - [Purely Functional Data Structures](https://doc.lagout.org/programmation/Functional%20Programming/Chris_Okasaki-Purely_Functional_Data_Structures-Cambridge_University_Press%281998%29.pdf)
    - [Git is a purely functional data structure](https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/)


:::info Copyright
- 文章作者: flytreeleft - [flytreeleft@crazydan.org](mailto:flytreeleft@crazydan.org)
- 版权声明: 本文章采用许可协议 [署名 4.0 国际 (CC BY 4.0)](https://creativecommons.org/licenses/by/4.0/)。
  转载请注明来自 [Crazydan Studio](https://studio.crazydan.org/)！
:::
