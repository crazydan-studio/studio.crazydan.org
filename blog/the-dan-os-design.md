---
title: Dan OS 设计
author: flytreleft
author_title: Creator of Crazydan Studio
author_url: https://flytreeleft.org
author_image_url: /img/avatar/flytreeleft.svg
tags:
- Dan OS
- 软件基础设施
- 新操作系统
- 数据结构化
- 应用函数化
description:
image:
---

> - Dan OS 的设计仍在逐步改进与完善中，本文将随时发生变化，感兴趣的朋友们可以时刻保持关注；
> - 在文末有本文编者的联系方式，有不同意见和建议的朋友可以与其保持联系；

`Dan OS`（也称为**蛋 OS**）是一款面向**结构化数据**和**函数化应用**的操作系统。

`Dan OS` 试图以**破局者**的身份，对当前的软件开发基础发起挑战，并提出其所认为的行之有效的、富有改革性的改进方案，
以实现从底层彻底（但不一定绝对）优化**软件基础设施**，让软件开发能够摆脱**思想枷锁**、卸下**历史包袱**，
从而向未来加速前进。

这不是一场「你生我灭」的斗争和较量，而是「后浪推前浪」的数字**进化与变革**。

`Dan OS` 必然是在基于前辈们大量的工作之上而诞生的，也必然是饱含「敬畏之心」的，
她也不会野心勃勃地去推翻一切以重建一个「乌邦托」的世界，她只是在以自己的行动向世人表明其对数字世界的变革之心，
并期望能够有更多人参与到这场变革之中，贡献出自己的想法与力量，让未来的数字世界变得更加美好。

<!-- more -->

## 应对挑战

### 数据格式的千奇百怪

当下的数据真的是格式种类和编解码方式繁多，且均“自成一派”，在集几代人智慧的结晶后，逐渐拥有完整且庞大的生态体系。

百花齐放本不是什么不好的事情，但从数字化的底层就开始各行其事，便在无形之中加重了数字化体系的整体负担，
让软件开发工作变得越发繁重，也让软件使用变得复杂，计算资源变得紧缺。

> 在应用交互和功能层面的“争奇斗艳”才是编者所真正期盼的。

各种数据格式在自己的生态内也许还能风生水起，但当要与其他生态进行数据交互时，便会变得困难起来。
因为，在不同的生态中会采用不同的编程语言，对相同数据会使用不同的编解码机制，
在消费端就需要编写相应的代码将生产端的数据进行解析，再向生产端返回其可以理解的格式化数据。

而在同一生态内，其存储的数据也和其在运行中所处理的数据不同，同样免不了地要进行数据的编解码工作。

也就是，无论是围绕数据格式的生态内外，均存在大量的代码、大量的计算资源，需要用于对数据的编解码上。
这也就使得在程序开发上，需要大量的人力和脑力资源消耗在数据格式转换和解析上。

并且，软件自身的维护成本也会上升，特别是在跨多个硬件平台、多个软件生态时，其所要维护的工作量也必然陡增。
工作量和维护成本的增加，也就会产生大量的显性和隐性的缺陷和漏洞，并反过来进一步提升开发成本。

其实，从本质上而言，各种数据格式也无太大差异，至少在应用程序处理时，
都免不了要将对应格式的数据转换为可识别的、业务逻辑清晰、数据指代明确的「结构化」数据。

但是，在多个位置、多个技术方案中对同一数据做转换，会因为理解不同、处理方式不同等因素，
造成数据解析出现偏差，并且，在涉及面很广的环境下，对数据格式做出变化也是极为困难的，
极易造成系统的不稳定，需要对代码进行大量调整和测试。

因此，只要在应用内外都采用**结构化数据**便能够避免以上问题，应用在拿到数据的那一刻都已经是结构化了的数据，
应用只需要依据确定的数据结构进行处理即可，无需再做任何转换，也不需要担心数据存在结构和语义不明的地方。

要做到这一点，仅靠对应用进行规范是无法彻底实现的。必须要从应用运行的底层（即，操作系统）作出改变才行。

此外，具备相同功能的应用在不同硬件平台上，也存在不同的（文件）格式，为了让程序在不同硬件上跑起来，
就必须将代码编译成不同的二进制代码。这同样是数据交换过程中的编解码行为，
只是该行为发生在操作系统层面而非应用层面。

但是，细究起来，**应用本身也是数据**，只不过其自身主要包含的是数据「处理函数」，
而这些处理函数会被编译成机器指令，操作系统再将这些指令喂给CPU去执行。

当然，函数没法实现结构化，并且，目前也无法将函数直接交给CPU执行，
但我们确实很有必要为应用中的处理函数提供统一且一致的跨平台的运行环境，
正如`JVM`（对应`Java`语言）、`BEAM`（对应`Erlang`语言）等代码执行的虚拟机一样，
让代码能够直接被解释执行，而无需再编译。

这样，应用的实体（二进制文件）也就不复存在，所留下的只有**数据 + 数据处理函数**，
整个操作系统也会成为一个大的函数体，负责执行其他函数（但不会缺失多线程等并发特性）。
各个应用之间也能够很方便地**共享函数**，而不是在二进制形式时，以动态链接库的形式共享数据处理能力，
数据也可以在不做迁移的情况下实现各类数据处理，只需要将数据处理函数分享到数据所在的系统上执行便可。

所以，`Dan OS` 需要做的便是：
- 将一切**数据结构化**，包括文件，避免在应用内外对数据进行编码和解码处理
  - 结构是自描述的、版本化的、向前兼容的
  - 数据结构的变化不影响未升级应用的稳定性（可适当无可展示的数据）
- 将**应用函数化**，不再以二进制方式分发应用，而是以函数形式分发和执行
  - 函数不与数据绑定，且必须是「幂等」的
- 使用**底层一致**的编程语言编写函数，从而消除代码不兼容和各自为政的状态
  - 在相同的底层语言之上可衍生各种领域模型语言或更高级的语言

### 应用生态的割裂与封闭

「以应用为中心」的数字化体系，正在堕入割裂与封闭的深渊，最终走向无尽的黑暗。

不同的应用有各自不同的开发机制、不同的操作逻辑、不同的处事哲学，使得用户体验各异，
应用之间割裂感严重，无法形成融合于操作系统的一致的数字化使用体验。

> 很多人推崇苹果电脑，也许正在于其统一且良好的用户体验所带来的流畅和舒适感。

围绕应用所形成的生态也具有排他性，因为其掌握对用户数据的「解释权」（即，如何解析数据），
所有改进尝试和功能扩展，均需要获得其许可，并遵守其随时可能发生变化的「游戏规则」。

在这样一个封闭的应用生态里，数据分享的壁垒将会越筑越高，商业的护城河也将越来越深。
数据的所有者反而逐步成为其「圈养的猪」，任何试图打破其壁垒的人都会被撞得头破血流。

应用生态间的数据，其存储格式、处理逻辑、展现风格等，都是不同的，数据无法在不同应用间共享。
数据所有者在通过某一生态内的应用创造了大量数据后，其便无法再切换到其他生态的应用上，
因为，切换应用，意味着前面产生的数据都将无法使用，一切就都得从头开始，
这样的切换成本是极为高昂的。

应用切换成本的高昂，反而使得应用成为「吸血的蚊子」，持续不断地为魔鬼输送养分。

割裂与封闭，势必造成生态内的优秀成果不能共享，用户的各类数据无法积累起来，
新的应用只能从零开始构建，从空白开始运行，用户也只能不断「在白纸上作画」。

所以，`Dan OS` 需要做的便是：
- **以数据为中心**构建应用生态，应用只是为数据服务，而不是数据的“管家”，
  用户可随时替换不满意的应用
  - **数据是用户的数据，而不是应用的数据**
- 应用可互相集成、互相调用，且交互体验上必须是一致和流畅的，应用不能“喧宾夺主”，
  要扮好数据服务者的角色
- 任何数据均具备唯一链接，其在应用间可相互跳转，在应用内也可以随时直达目标数据

### 应用臃肿与计算资源不够用

- 应用安装体积越来越到，大量功能不会用到或极少用到
- 计算机内存和CPU逐年提升，在运行应用时依然响应迟钝

### 用户数据的所有权与控制权

<!--
去中心化只是附属产物，其也不是与中心化完全对立。只是为了让数据的所有者能够对自己的数据拥有更多的控制权和处置权，
让中心化服务商对用户数据更有敬畏之心，厂商之间能够更加良性竞争。
-->

「去中心化」不是目的，而是将数据所有权、控制权和处置权归还数据所有者的结果。

为了实现该结果，应用可以是去中心化的，也可以是中心化的，或者二者相结合，数据存储可以是分布式，也可以集中式。

数据所有者对数据的权利，就像是你对自己所拥有的实物的权利，只能由你自己决定所属物该如何使用和处理，其他人均无权干预，甚至都不知道其存在。

### 软件开发中的重复踩坑

前人遇过的坑，后人又不得不继续踩坑，软件开发史就是一部「血泪踩坑史」。

排雷成果难以共享和直接使用，阻碍共同进步。

各个项目均需要开发大量逻辑类似（但有些许差异）的组件，尽管各种开发语言都有很多框架，但都会引入不同程度的入门难度、开发复杂度，以及各种缺陷。

### 生产环境与测试环境的差异

测试环境难以复现生产环境中出现的问题，克隆完全的生产环境需要消耗大量的时间和人力成本，在生产上做测试需要小心翼翼，往往测试不足。

### 软件开发中的依赖问题

- 依赖版本变更问题
- 依赖复杂度问题
- 依赖引入缺陷及缺陷修复问题

### 变更回溯与灾备

- 应用断点恢复，零重启、零准备

### 应用与数据安全

- 应用隔离
- 权限最小化，权限控制到函数及数据属性
- 数据加密
- 数据访问跟踪

### 万物互联

- 所有外设都是计算的延伸，主要是用于接收输入、反馈输出
- 待处理数据量大
- 数据安全、使用者身份认证和权限控制

## 功能特性

- 一切皆为结构化数据：数据自带结构，消除编解码
- 统一且一致的分布式层：开放，连接，协作，共享
- 统一且一致的数据存取层：高存取性能，规模无关；结构化数据，数据之间任意层级的关联和实时查询
- 统一且一致的程序语言：消除程序碎片化与应用隔离，强制共建互利生态
- 统一且一致的开发界面：数据定义及引用界面；函数编写界面；应用配置界面；数据查询界面；用户端组装界面；
- 应用程序函数化，函数可共享，可迁移：减少重造的轮子，成果共享（仅结果非资产共享），实现生态内互利
- 函数及数据版本化：依赖升级无破坏性，变更可跟踪可回溯
- 应用间运行环境完全隔离，以消息交换数据，权限最小化
- 中断的应用可从中断位置继续运行：灾难恢复
- 原生且默认的数据加密
- 在自身这端提供对旧世界的接入层，该接入层以原有方式与其对接，再对收到的数据结构化后，返回给调用端（反之为该过程的逆过程），系统提供通用的对接支持和相应的工具

## 架构设计

<img src="/img/danos/arch-v1.0.jpg" alt="Dan OS 架构 v1.0" height="600px"/>

## 相关阅读

- [一种新的操作系统设计](http://www.yinwang.org/blog-cn/2013/04/14/os-design):
  转载文章在[这里](./a-new-os-design-by-wangyin)。
- [Pick Operating System](https://en.wikipedia.org/wiki/Pick_operating_system):
  A demand-paged, multiuser, virtual memory, time-sharing computer operating system
  based around a MultiValue database.


:::info Copyright
- 文章作者: flytreeleft - [flytreeleft@crazydan.org](mailto:flytreeleft@crazydan.org)
- 版权声明: 本文章采用许可协议 [署名 4.0 国际 (CC BY 4.0)](https://creativecommons.org/licenses/by/4.0/)。
  转载请注明来自 [Crazydan Studio](https://studio.crazydan.org/)！
:::
